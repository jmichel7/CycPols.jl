var documenterSearchIndex = {"docs":
[{"location":"#CycPols","page":"Home","title":"CycPols","text":"Documentation for CycPols.","category":"section"},{"location":"#CycPols.CycPols","page":"Home","title":"CycPols.CycPols","text":"This package deals with products of Cyclotomic polynomials.\n\nCyclotomic  numbers, and cyclotomic polynomials  over the rationals or some cyclotomic  field, are important in the theories of finite reductive groups and  Spetses. In particular Schur elements of cyclotomic Hecke algebras are products of cyclotomic polynomials.\n\nThe  type CycPol represents the product of a coeff (a constant, a  polynomial  or  a  rational  fraction  in  one variable) with a rational fraction  in one variable with  all poles or zeroes  equal to 0 or roots of unity.  The advantages of  representing as CycPol  such objects are: nice display  (factorized),  less  storage,  fast  multiplication,  division and evaluation.   The  drawback  is  that  addition  and  subtraction  are  not implementedðŸ˜ž\n\nThis   package  uses   the  polynomials   Pol  defined   by  the  package LaurentPolynomials  and  the  cyclotomic  numbers  Cyc  defined  by the package CyclotomicNumbers.\n\nThe  method  CycPol(a::Pol)  converts  a  to  a CycPol by finding the largest  cyclotomic polynomial  dividing, leaving  a Pol coefficient if some roots of the polynomial are not roots of unity.\n\njulia> using LaurentPolynomials\n\njulia> @Pol q\nPol{Int64}: q\n\njulia> p=CycPol(q^25-q^24-2q^23-q^2+q+2) # a `Pol` coefficient remains\n(q-2)Î¦â‚Î¦â‚‚Î¦â‚‚â‚ƒ\n\njulia> p(q) # evaluate CycPol p at q\nPol{Int64}: qÂ²âµ-qÂ²â´-2qÂ²Â³-qÂ²+q+2\n\njulia> p*inv(CycPol(q^2+q+1)) # `*`, `inv`, `/` and `//` are defined\n(q-2)Î¦â‚Î¦â‚‚Î¦â‚ƒâ»Â¹Î¦â‚‚â‚ƒ\n\njulia> -p  # one can multiply by a scalar\n(-q+2)Î¦â‚Î¦â‚‚Î¦â‚‚â‚ƒ\n\njulia> valuation(p)\n0\n\njulia> degree(p)\n25\n\njulia> lcm(p,CycPol(q^3-1)) # lcm is fast between CycPols\n(q-2)Î¦â‚Î¦â‚‚Î¦â‚ƒÎ¦â‚‚â‚ƒ\n\njulia> print(p)\nCycPol(Pol([-2, 1]),0,(1,0),(2,0),(23,0)) # a format which can be read in Julia\n\nEvaluating  a CycPol at some Pol value  gives in general a Pol. There are  exceptions  where  we  can  keep  the  value a CycPol: evaluating at Pol()^n  (that is q^n) or at  Pol([E(n,k)],1) (that is qÎ¶â‚™áµ). Then subs gives that evaluation:\n\njulia> subs(p,Pol()^-1) # evaluate as a CycPol at qâ»Â¹\n(2-qâ»Â¹)qâ»Â²â´Î¦â‚Î¦â‚‚Î¦â‚‚â‚ƒ\n\njulia> using CyclotomicNumbers\n\njulia> subs(p,Pol([E(2)],1)) # or at -q\n(-q-2)Î¦â‚Î¦â‚‚Î¦â‚„â‚†\n\nThe variable name used when printing a CycPol is the same as for Pols.\n\nWhen  showing  a  CycPol,  some  factors  over  extension  fields  of the cyclotomic polynomial Î¦â‚™ are given a special name. If n has a primitive root  Î¾, Ï•â€²â‚™ is the product of the  (q-Î¶) where Î¶ runs over the odd powers  of Î¾, and Ï•â€³â‚™ is the  product for the even powers. Some further factors are recognized for small n. \n\njulia> CycPol(q^6-E(4))\nÎ¦â€³â‚ˆÎ¦â½Â¹Â³â¾â‚‚â‚„\n\nThe  function show_factors gives the  complete list of recognized factors for a given n:\n\njulia> CycPols.show_factors(24)\n15-element Vector{Tuple{CycPol{Int64}, Pol}}:\n (Î¦â‚‚â‚„, qâ¸-qâ´+1)\n (Î¦â€²â‚‚â‚„, qâ´+Î¶â‚ƒÂ²)\n (Î¦â€³â‚‚â‚„, qâ´+Î¶â‚ƒ)\n (Î¦â€´â‚‚â‚„, qâ´-âˆš2qÂ³+qÂ²-âˆš2q+1)\n (Î¦â—â‚‚â‚„, qâ´+âˆš2qÂ³+qÂ²+âˆš2q+1)\n (Î¦â½âµâ¾â‚‚â‚„, qâ´-âˆš6qÂ³+3qÂ²-âˆš6q+1)\n (Î¦â½â¶â¾â‚‚â‚„, qâ´+âˆš6qÂ³+3qÂ²+âˆš6q+1)\n (Î¦â½â·â¾â‚‚â‚„, qâ´+âˆš-2qÂ³-qÂ²-âˆš-2q+1)\n (Î¦â½â¸â¾â‚‚â‚„, qâ´-âˆš-2qÂ³-qÂ²+âˆš-2q+1)\n (Î¦â½â¹â¾â‚‚â‚„, qÂ²+Î¶â‚ƒÂ²âˆš-2q-Î¶â‚ƒ)\n (Î¦â½Â¹â°â¾â‚‚â‚„, qÂ²-Î¶â‚ƒÂ²âˆš-2q-Î¶â‚ƒ)\n (Î¦â½Â¹Â¹â¾â‚‚â‚„, qÂ²+Î¶â‚ƒâˆš-2q-Î¶â‚ƒÂ²)\n (Î¦â½Â¹Â²â¾â‚‚â‚„, qÂ²-Î¶â‚ƒâˆš-2q-Î¶â‚ƒÂ²)\n (Î¦â½Â¹Â³â¾â‚‚â‚„, qâ´-Î¶â‚„qÂ²-1)\n (Î¦â½Â¹â´â¾â‚‚â‚„, qâ´+Î¶â‚„qÂ²-1)\n\nSuch a factor can be obtained directly as:\n\njulia> CycPol(;conductor=24,no=7)\nÎ¦â½â·â¾â‚‚â‚„\n\njulia> CycPol(;conductor=24,no=7)(q)\nPol{Cyc{Int64}}: qâ´+âˆš-2qÂ³-qÂ²-âˆš-2q+1\n\nThis package also defines the function cyclotomic_polynomial:\n\njulia> p=cyclotomic_polynomial(24)\nPol{Int64}: qâ¸-qâ´+1\n\njulia> CycPol(p) # same as CycPol(;conductor=24,no=0)\nÎ¦â‚‚â‚„\n\n\n\n\n\n","category":"module"},{"location":"#CycPols.subs","page":"Home","title":"CycPols.subs","text":"subs(p::CycPol,v::Pol)\n\na fast routine to compute CycPol(p(v)) but works for only two types of polynomials:\n\nv=Pol([e],1) for e a Root1, that is the value at qe for e=Î¶â‚™áµ\nv=Pol([1],n) that is the value at qâ¿\n\njulia> p=CycPol(Pol()^2-1)\nÎ¦â‚Î¦â‚‚\n\njulia> subs(p,Pol([E(3)],1))\nÎ¶â‚ƒÂ²Î¦â€³â‚ƒÎ¦â€²â‚†\n\njulia> subs(p,Pol()^2)\nÎ¦â‚Î¦â‚‚Î¦â‚„\n\n\n\n\n\n","category":"function"},{"location":"#CycPols.cyclotomic_polynomial","page":"Home","title":"CycPols.cyclotomic_polynomial","text":"cyclotomic_polynomial(n)\n\nreturns the n-th cyclotomic polynomial.\n\njulia> cyclotomic_polynomial(5)\nPol{Int64}: qâ´+qÂ³+qÂ²+q+1\n\njulia> cyclotomic_polynomial(24)\nPol{Int64}: qâ¸-qâ´+1\n\n\n\n\n\n","category":"function"},{"location":"#CycPols.CycPol","page":"Home","title":"CycPols.CycPol","text":"CycPols are internally a struct with fields:\n\n.coeff:  a coefficient, usually a Cyc or a Pol. The Pol case allows    to represent as CycPols arbitrary Pols which is useful sometimes.\n\n.valuation: an Int.\n\n.v: a ModuleElt{Rational{Int},Int} where pairs r=>m give the multiplicity m of Root1(;r=r) as a root.\n\nSo CycPol(coeff,val,v) represents coeff*q^val*prod((q-Root1(;r=r))^m for (r,m) in v).\n\n\n\n\n\n","category":"type"}]
}
